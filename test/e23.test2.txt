import { expect, use } from "chai";
import { ethers } from "hardhat";
import {
  AbiCoder,
  BytesLike,
  Signer,
  ZeroAddress,
  keccak256,
  toNumber,
  type BigNumberish,
} from "ethers";
import { existsSync, mkdirSync } from "fs";

import { Keypair, Message, PCommand, PubKey } from "maci-domainobjs";
import { ITallyCircuitInputs, MaciState, Poll } from "maci-core";
import {
  genTreeCommitment,
  genTreeCommitment as genTallyResultCommitment,
  genRandomSalt,
} from "maci-crypto";
import {
  ERC20,
  MessageProcessor,
  MessageProcessor__factory,
  MockVerifier,
  Verifier,
  Poll__factory,
  VkRegistry,
} from "maci-contracts";

import { addTallyResultsBatch, createMessage } from "./utils/maci";

import { DEFAULT_CIRCUIT, getCircuitFiles } from "./utils/circuits";

import { MaciParameters } from "./utils/maciParameters";

import { JSONFile } from "./utils/JSONFile";

import {
  UNIT,
  ALPHA_PRECISION,
  DEFAULT_GET_LOG_BATCH_SIZE,
  DEFAULT_SR_QUEUE_OPS,
} from "./utils/constants";

import { getIpfsHash } from "./utils/ipfs";

import {
  mergeMessages,
  mergeSignups,
  genProofs,
  proveOnChain,
  GenProofsArgs,
  genLocalState,
  verify,
  TallyData,
  publish,
} from "maci-cli";

import type { EthereumProvider } from "hardhat/types";

import {
  QVMACI,
  ClonableMACI,
  ClonablePoll,
  ClonableTally,
  ClonableMessageProcessor,
  Allo,
} from "../typechain-types";
import {
  STATE_TREE_DEPTH,
  deployTestContracts,
  maxValues,
  messageBatchSize,
  timeTravel,
  treeDepths,
} from "./utils";
import { QVMACIInterface } from "../typechain-types/contracts/strategies/qv-maci/QVMACI";
import { ClonableMACIInterface } from "../typechain-types/contracts/ClonableMaciContracts/ClonableMACI";

import { getTalyFilePath, isPathExist } from "./utils/misc";
import path from "path";

import { genMaciStateFromContract } from "maci-contracts";

import os from "os";

/**
 * Merge MACI message and signups subtrees
 * Must merge the subtrees before calling genProofs
 * @param maciAddress MACI contract address
 * @param pollId Poll id
 * @param numQueueOps Number of operations to perform for the merge
 * @param quiet Whether to log output
 */
export async function mergeMaciSubtrees({
  maciAddress,
  pollId,
  numQueueOps,
  signer,
  quiet,
}: {
  maciAddress: string;
  pollId: bigint;
  signer: Signer;
  numQueueOps?: string;
  quiet?: boolean;
}) {
  if (!maciAddress) throw new Error("Missing MACI address");

  await mergeMessages({
    pollId,
    maciContractAddress: maciAddress,
    numQueueOps,
    signer,
    quiet,
  });

  await mergeSignups({
    pollId,
    maciContractAddress: maciAddress,
    numQueueOps,
    signer,
    quiet,
  });
}

/* Input to getGenProofArgs() */
type getGenProofArgsInput = {
  maciAddress: string;
  pollId: bigint;
  // coordinator's MACI serialized secret key
  coordinatorMacisk: string;
  // the transaction hash of the creation of the MACI contract
  maciTxHash?: string;
  // the key get zkeys file mapping, see utils/circuits.ts
  circuitType: string;
  circuitDirectory: string;
  rapidsnark?: string;
  // where the proof will be produced
  outputDir: string;
  // number of blocks of logs to fetch per batch
  blocksPerBatch: number;
  // fetch logs from MACI from these start and end blocks
  startBlock?: number;
  endBlock?: number;
  // MACI state file
  maciStateFile?: string;
  // Tally output file
  tallyFile: string;
  // transaction signer
  signer: Signer;
  // flag to turn on verbose logging in MACI cli
  quiet?: boolean;
};

// MACI zkFiles
const circuit = process.env.CIRCUIT_TYPE || DEFAULT_CIRCUIT;
const circuitDirectory = process.env.CIRCUIT_DIRECTORY || "./../zkeys/zkeys";
const rapidsnark = process.env.RAPID_SNARK || "~/rapidsnark/package/bin/prover";
const proofOutputDirectory = process.env.PROOF_OUTPUT_DIR || "./proof_output";
const tallyBatchSize = Number(process.env.TALLY_BATCH_SIZE || 8);
export const isOsArm = os.arch().includes("arm");

type ClaimData = { [index: number]: bigint };

/*
 * Get the arguments to pass to the genProof function
 */
export function getGenProofArgs(args: getGenProofArgsInput): GenProofsArgs {
  const {
    maciAddress,
    coordinatorMacisk,
    maciTxHash,
    circuitType,
    circuitDirectory,
    outputDir,
    blocksPerBatch,
    maciStateFile,
    tallyFile,
    signer,
  } = args;

  const {
    processZkFile,
    tallyZkFile,
    processWitness,
    processWasm,
    processDatFile,
    tallyWitness,
    tallyWasm,
    tallyDatFile,
  } = getCircuitFiles(circuitType, circuitDirectory);
  return {
    outputDir,
    tallyFile,
    tallyZkey: tallyZkFile,
    processZkey: processZkFile,
    pollId: 0n,
    coordinatorPrivKey: coordinatorMacisk,
    maciAddress: maciAddress,
    transactionHash: maciTxHash,
    processWasm: processWasm,
    tallyWasm: tallyWasm,
    useWasm: true,
    blocksPerBatch: blocksPerBatch,
    stateFile: maciStateFile,
    signer: signer,
    quiet: true,
  };
}

describe("e2e2", function test() {
  this.timeout(90000000);

  let QVMaciStrategy: QVMACI;
  let QVMaciStrategyAddress: string;
  let token: ERC20;

  let Coordinator: Signer;
  let allocator: Signer;
  let recipient1: Signer;
  let recipient2: Signer;
  let CoordinatorAddress: string;

  // create a new user keypair
  const keypair = new Keypair();

  const coordinatorKeypair = new Keypair();

  const serializedCoordinatorPubKey = coordinatorKeypair.pubKey.serialize();

  let iface: QVMACIInterface;
  let ifaceClonableMACI: ClonableMACIInterface;
  let verifierContract: Verifier;
  let vkRegistryContract: VkRegistry;
  let maciContract: ClonableMACI;
  let pollContract: ClonablePoll;
  let tallyContract: ClonableTally;
  let mpContract: ClonableMessageProcessor;
  let AlloContract: Allo;

  const signupAmount = 100_000_000_000_000n;

  before(async () => {
    [Coordinator] = await ethers.getSigners();

    CoordinatorAddress = await Coordinator.getAddress();

    const contracts = await deployTestContracts();

    AlloContract = contracts.Allo;
    QVMaciStrategy = contracts.QVMACI_STRATEGY;
    pollContract = contracts.pollContract;
    verifierContract = contracts.verifierContract;
    vkRegistryContract = contracts.vkRegistryContract;
    maciContract = contracts.maciContract;
    QVMaciStrategyAddress = await QVMaciStrategy.getAddress();
    allocator = contracts.user1;
    recipient1 = contracts.user2;
    recipient2 = contracts.user3;

    iface = QVMaciStrategy.interface;
    ifaceClonableMACI = maciContract.interface;
  });

  describe("deployment", function () {
    it("should have deployed a new MinimalQf instance", async () => {
      expect(await QVMaciStrategy.getAddress()).to.not.be.undefined;
      expect(await maciContract.stateTreeDepth()).to.eq(6n);
    });
  });

  describe("Add Allocator", () => {
    it("Pool Admin should allowlist an allocator", async () => {
      const tx = await QVMaciStrategy.addAllocator(
        await allocator.getAddress()
      );

      const receipt = await tx.wait();

      expect(receipt?.status).to.eq(1);

      // emit AllocatorAdded(_allocator, msg.sender);

      // Store the state index
      const log = receipt!.logs[receipt!.logs.length - 1];
      const event = iface.parseLog(
        log as unknown as { topics: string[]; data: string }
      ) as unknown as {
        args: {
          allocator: string;
          sender: string;
        };
      };

      expect(event.args.sender).to.eq(CoordinatorAddress);
      expect(event.args.allocator).to.eq(await allocator.getAddress());
    });
  });

  describe("signup", () => {
    it("should allow to signup an allowed allocator", async () => {
      const tx = await QVMaciStrategy.connect(allocator).signup(
        keypair.pubKey.asContractParam()
      );

      const receipt = await tx.wait();

      expect(receipt?.status).to.eq(1);

      // Store the state index
      const log = receipt!.logs[receipt!.logs.length - 1];
      const event = ifaceClonableMACI.parseLog(
        log as unknown as { topics: string[]; data: string }
      ) as unknown as {
        args: {
          _stateIndex: BigNumberish;
          _voiceCreditBalance: BigNumberish;
        };
      };

      expect(event.args._stateIndex).to.eq(1n);
      expect(event.args._voiceCreditBalance).to.eq(100n);
    });
  });

  describe("registerRecipient", () => {
    it("should allow anyone to register their project", async () => {
      let recipientAddress = await recipient1.getAddress();
      let data = AbiCoder.defaultAbiCoder().encode(
        ["address", "address", "(uint256,string)"],
        [recipientAddress, ZeroAddress, [1n, "Project 1"]]
      );
      const tx = await AlloContract.connect(recipient1).registerRecipient(
        1n,
        data
      );

      const receipt = await tx.wait();

      expect(receipt?.status).to.eq(1);
      // event Registered(address indexed recipientId, bytes data, address sender);

      // Store the state index
      const log = receipt!.logs[receipt!.logs.length - 1];
      const event = iface.parseLog(
        log as unknown as { topics: string[]; data: string }
      ) as unknown as {
        args: {
          recipientId: string;
          data: BytesLike;
          sender: string;
        };
      };

      expect(event.args.recipientId).to.eq(recipientAddress);
      expect(event.args.data).to.eq(data);
      expect(event.args.sender).to.eq(recipientAddress);
    });
  });

  describe("reviewRecipient", () => {
    it("should allow the pool admin to review the project recipient", async () => {
      let recipientAddress = await recipient1.getAddress();
      let status = 2; // Accepted

      const tx = await QVMaciStrategy.connect(Coordinator).reviewRecipients(
        [recipientAddress],
        [status]
      );

      // const votingIndexBytes = AbiCoder.defaultAbiCoder().encode(["address"], [recipientAddress])
      // const votingIndex = ethers.utils.keccak256(votingIndexBytes) as BytesLike

      const receipt = await tx.wait();

      expect(receipt?.status).to.eq(1);

      const votingOption =
        await QVMaciStrategy.connect(Coordinator).recipientIdToIndex(
          recipientAddress
        );

      // event RecipientVotingOptionAdded(address recipientId, uint256 recipientIndex);

      const log = receipt!.logs[receipt!.logs.length - 1];
      const event = iface.parseLog(
        log as unknown as { topics: string[]; data: string }
      ) as unknown as {
        args: {
          recipientId: string;
          recipientIndex: BytesLike;
        };
      };

      expect(event.args.recipientId).to.eq(recipientAddress);
      // expect(event.args.recipientIndex).to.eq(votingOption)
    });
  });

  describe("publish message", () => {
    it("should allow to publish a message", async () => {
      const keypair = new Keypair();

      let recipientAddress = await recipient1.getAddress();

      const votingOption =
        await QVMaciStrategy.connect(Coordinator).recipientIdToIndex(
          recipientAddress
        );

      const command = new PCommand(
        1n,
        keypair.pubKey,
        votingOption,
        9n,
        1n,
        0n,
        0n
      );

      const signature = command.sign(keypair.privKey);
      const sharedKey = Keypair.genEcdhSharedKey(
        keypair.privKey,
        coordinatorKeypair.pubKey
      );
      const message = command.encrypt(signature, sharedKey);
      await pollContract
        .connect(allocator)
        .publishMessage(message, keypair.pubKey.asContractParam());
    });

    it("should allow to publish a batch of messages", async () => {
      const keypair = new Keypair();

      let recipientAddress = await recipient1.getAddress();

      const votingOption =
        await QVMaciStrategy.connect(Coordinator).recipientIdToIndex(
          recipientAddress
        );

      const command = new PCommand(
        1n,
        keypair.pubKey,
        votingOption,
        9n,
        1n,
        0n,
        0n
      );

      const signature = command.sign(keypair.privKey);
      const sharedKey = Keypair.genEcdhSharedKey(
        keypair.privKey,
        coordinatorKeypair.pubKey
      );
      const message = command.encrypt(signature, sharedKey);

      const messages = new Array(10).fill(message.asContractParam());
      const keys = new Array(10).fill(keypair.pubKey.asContractParam());

      await pollContract
        .connect(allocator)
        .publishMessageBatch(messages, keys, { gasLimit: 30000000 });
    });
  });

  describe("finalize", () => {
    const maciParamss = new MaciParameters();
    let mpContract: MessageProcessor;
    let poll: Poll;

    let tallyData: ITallyCircuitInputs;
    let QVMaciStrategy: QVMACI;
    let QVMaciStrategyAddress: string;

    let Coordinator: Signer;
    let allocator: Signer;
    let recipient1: Signer;
    let recipient2: Signer;
    let CoordinatorAddress: string;

    // create a new user keypair
    const keypair = new Keypair();
    let coordinatorKeypair: Keypair;
    let proofOutputDirectory = "proofs";
    let DEFAULT_GET_LOG_BATCH_SIZE = 1000;
    let maciTransactionHash: string;
    let iface: QVMACIInterface;
    let ifaceClonableMACI: ClonableMACIInterface;
    let verifierContract: Verifier;
    let vkRegistryContract: VkRegistry;
    let maciContract: ClonableMACI;
    let pollContract: ClonablePoll;
    let tallyContract: ClonableTally;
    let AlloContract: Allo;

    let deployTime: number;

    let quiet = true as any;

    before(async () => {
      const maciParams = await MaciParameters.fromConfig(
        "micro",
        circuitDirectory
      );

      [Coordinator] = await ethers.getSigners();

      CoordinatorAddress = await Coordinator.getAddress();
      const contracts = await deployTestContracts();

      const deployTime = contracts.poolDeployTime || 0;

      // const pollId = maciState.deployPoll(
      //   BigInt(deployTime)+500n,
      //   {
      //     // maxMessages and maxVoteOptions are calculated using treeArity = 5 as seen in the following code:
      //     // https://github.com/privacy-scaling-explorations/maci/blob/master/contracts/contracts/Poll.sol#L115
      //     // treeArity ** messageTreeDepth
      //     maxMessages: (5 ** 9),
      //     // treeArity ** voteOptionTreeDepth
      //     maxVoteOptions: (5 ** 3),
      //   },
      //   {
      //     ...maciParams.treeDepths,
      //     intStateTreeDepth: maciParams.stateTreeDepth,
      //   },
      //   maciParams.getMessageBatchSize(),
      //   coordinatorKeypair
      // );

      AlloContract = contracts.Allo;
      QVMaciStrategy = contracts.QVMACI_STRATEGY;
      pollContract = contracts.pollContract;
      tallyContract = contracts.tallyContract;
      mpContract = contracts.messageProcessorContract;
      verifierContract = contracts.verifierContract;
      vkRegistryContract = contracts.vkRegistryContract;
      maciContract = contracts.maciContract;
      QVMaciStrategyAddress = await QVMaciStrategy.getAddress();
      allocator = contracts.user1;
      recipient1 = contracts.user2;
      recipient2 = contracts.user3;
      maciTransactionHash = contracts.maciTransitionHash || "";
      coordinatorKeypair = contracts.CoordinatorKeypair;

      iface = QVMaciStrategy.interface;
      ifaceClonableMACI = maciContract.interface;

      let _mpContract = mpContract.connect(Coordinator);

      // Add allocator
      const addAllocatorTx = await QVMaciStrategy.addAllocator(
        await allocator.getAddress()
      );
      await addAllocatorTx.wait();

      // signup
      const SignUpTx = await QVMaciStrategy.connect(allocator).signup(
        keypair.pubKey.asContractParam()
      );
      await SignUpTx.wait();

      // Register recipient
      let recipientAddress = await recipient1.getAddress();
      let data = AbiCoder.defaultAbiCoder().encode(
        ["address", "address", "(uint256,string)"],
        [recipientAddress, ZeroAddress, [1n, "Project 1"]]
      );
      const RecipientRegistrationTx = await AlloContract.connect(
        recipient1
      ).registerRecipient(1n, data);
      await RecipientRegistrationTx.wait();

      // Review Acccept recipient
      let status = 2; // Accepted
      const ReviewRecipientTx = await QVMaciStrategy.connect(
        Coordinator
      ).reviewRecipients([recipientAddress], [status]);
      await ReviewRecipientTx.wait();

      // create 1 message for the recipient
      const votingOption =
        await QVMaciStrategy.connect(Coordinator).recipientIdToIndex(
          recipientAddress
        );
      const command = new PCommand(
        1n,
        keypair.pubKey,
        votingOption,
        9n,
        0n,
        0n,
        0n
      );
      const signature = command.sign(keypair.privKey);
      const sharedKey = Keypair.genEcdhSharedKey(
        keypair.privKey,
        coordinatorKeypair.pubKey
      );
      const message = command.encrypt(signature, sharedKey);
      const messageContractParam = message.asContractParam();

      // merge the trees
      const _pollContract = pollContract.connect(Coordinator);

      await _pollContract.publishMessage(
        messageContractParam,
        keypair.pubKey.asContractParam()
      );

      const maciAddress = await maciContract.getAddress();

      // await publish({
      //   pubkey: keypair.pubKey.serialize(),
      //   stateIndex: 1n,
      //   voteOptionIndex: votingOption,
      //   nonce: 1n,
      //   pollId: 0n,
      //   newVoteWeight: 9n,
      //   maciContractAddress: maciAddress,
      //   salt: genRandomSalt(),
      //   privateKey: keypair.privKey.serialize(),
      //   signer:allocator,
      // });

      await timeTravel(
        Coordinator.provider as unknown as EthereumProvider,
        600
      );

      await mergeMaciSubtrees({
        maciAddress,
        // pollId,
        pollId: 0n,
        numQueueOps: DEFAULT_SR_QUEUE_OPS,
        signer: Coordinator,
      });

      const maciState = await genMaciStateFromContract(
        Coordinator.provider!,
        maciAddress,
        coordinatorKeypair,
        0n,
      );

      const state = maciState.toJSON();

      const random = Math.floor(Math.random() * 10 ** 8);

      const outputDir = path.join(proofOutputDirectory, `${random}`);
      if (!existsSync(outputDir)) {
        mkdirSync(outputDir, { recursive: true });
      }

      const tallyFile = getTalyFilePath(outputDir);

      const {
        processZkFile,
        tallyZkFile,
        processWitness,
        processWasm,
        tallyWitness,
        tallyWasm,
      } = getCircuitFiles("micro", circuitDirectory);
      await genProofs({
        outputDir: outputDir,
        tallyFile: tallyFile,
        tallyZkey: tallyZkFile,
        processZkey: processZkFile,
        pollId: 0n,
        rapidsnark: undefined,
        processWitgen: processWitness,
        processDatFile: undefined,
        tallyWitgen: tallyWitness,
        tallyDatFile: undefined,
        coordinatorPrivKey: coordinatorKeypair.privKey.serialize(),
        maciAddress: maciAddress,
        transactionHash: maciTransactionHash,
        processWasm: processWasm,
        tallyWasm: tallyWasm,
        useWasm: true,
        stateFile: undefined,
        startBlock: undefined,
        blocksPerBatch: 50,
        endBlock: undefined,
        signer: Coordinator,
        tallyAddress: await tallyContract.getAddress(),
        useQuadraticVoting: true,
        quiet: false,
      } as GenProofsArgs);

      const tallyAddress = await tallyContract.getAddress();
      const messageProcessorAddress = await mpContract.getAddress();

      // Submit proofs to MACI contract
      await proveOnChain({
        pollId: 0n,
        proofDir: outputDir,
        subsidyEnabled: false,
        maciAddress,
        messageProcessorAddress,
        tallyAddress,
        signer: Coordinator,
        quiet,
      });

      console.log("finished proveOnChain");

      const tally = JSONFile.read(tallyFile) as any;
      const tallyHash = await getIpfsHash(tally);

      await QVMaciStrategy.connect(Coordinator).publishTallyHash(tallyHash);
      console.log("Tally hash", tallyHash);

      // add tally results to funding round
      const recipientTreeDepth = treeDepths.voteOptionTreeDepth;
      console.log("Adding tally result on chain in batches of", tallyBatchSize);
      await addTallyResultsBatch(
        QVMaciStrategy.connect(Coordinator) as QVMACI,
        recipientTreeDepth,
        tally,
        tallyBatchSize
      );
      console.log("Finished adding tally results");

      const newResultCommitment = genTallyResultCommitment(
        tally.results.tally.map((x: string) => BigInt(x)),
        BigInt(tally.results.salt),
        recipientTreeDepth
      );

      const perVOSpentVoiceCreditsCommitment = genTallyResultCommitment(
        tally.perVOSpentVoiceCredits.tally.map((x: string) => BigInt(x)),
        BigInt(tally.perVOSpentVoiceCredits.salt),
        recipientTreeDepth
      );

      // Finalize round
      await QVMaciStrategy.finalize(
        tally.totalSpentVoiceCredits.spent,
        tally.totalSpentVoiceCredits.salt,
        newResultCommitment.toString(),
        perVOSpentVoiceCreditsCommitment.toString()
      );
    });

    it("Recipient should have more than 0 votes received", async () => {
      let recipientAddress = await recipient1.getAddress();
      let recipient = await QVMaciStrategy.recipients(recipientAddress);
      // expect(recipient.totalVotesReceived).to.be.gt(0);
    });
  });
});
